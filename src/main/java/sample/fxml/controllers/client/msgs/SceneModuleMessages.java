// Generated by tool. DO NOT EDIT!

package sample.fxml.controllers.client.msgs;

import org.jboss.netty.buffer.ChannelBuffer;

import sample.fxml.controllers.client.Modules;

import static sample.utils.BufferUtil.computeUTF;
import static sample.utils.BufferUtil.computeVarInt32Size;
import static sample.utils.BufferUtil.computeVarInt64Size;
import static sample.utils.BufferUtil.newDynamicMessage;
import static sample.utils.BufferUtil.newFixedSizeMessage;
import static sample.utils.BufferUtil.onlySendHeadAndAByteMessage;
import static sample.utils.BufferUtil.onlySendHeaderMessage;
import static sample.utils.BufferUtil.writeUTF;
import static sample.utils.BufferUtil.writeVarInt32;
import static sample.utils.BufferUtil.writeVarInt64;


public class SceneModuleMessages {

    public static final int MODULE_ID = Modules.SCENE_MODULE_ID;

    /**
     * 客户端请求轻功,服务器直接跳跃并广播
     *
     * varint32 格子x
     * varint32 格子y
     * varint32 速度
     * varint32 时间毫秒
     */
    public static final int C2S_JUMP = 1;

    /**
     * 英雄跳广播
     *
     * string 角色id
     * varint32 格子x
     * varint32 格子y
     * varint32 速度
     * varint32 时间毫秒
     */
    public static final int S2C_JUMP_OK = 1;

    public static ChannelBuffer jumpOk(String id, int x, int y, int speed, int time) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_JUMP_OK,
                computeUTF(id) + computeVarInt32Size(x) + computeVarInt32Size(y) + computeVarInt32Size(speed) + computeVarInt32Size(time));
        writeUTF(buffer, id);
        writeVarInt32(buffer, x);
        writeVarInt32(buffer, y);
        writeVarInt32(buffer, speed);
        writeVarInt32(buffer, time);
        return buffer;
    }

    /**
     * 英雄移动, 发送各个转弯的节点, 包括自己当前所站的那一点
     *
     * varint32 总共的节点数
     *
     * for 每个节点 {
     *
     * varint32 x坐标
     *
     * varint32 y坐标
     *
     * }
     */
    public static final int C2S_MOVE = 2;

    /**
     * 场景中有英雄/怪物/宠物啥的 移动了, 包含每个节点和到达这个节点的时间
     *
     * string 移动的对象的id
     *
     * varint64 移动速度 (每秒走的像素)
     *
     * varint32 从起始点开始走的时间 (第一点)(秒)
     *
     * varint32 总共的节点数
     *
     * for 每个节点 {
     *
     * varint32 x 坐标
     *
     * varint32 y 坐标
     *
     * }
     */
    public static final int S2C_MOVE_OK = 2;

    public static ChannelBuffer moveOk() {
        return newDynamicMessage(MODULE_ID, S2C_MOVE_OK);
    }

    /**
     * 登陆时进入场景,可进入场景时发送,发送完等待服务器消息
     *
     * varint32 视野范围 viewRange
     */
    public static final int C2S_SCENE_LOAD = 3;

    /**
     * 进入场景成功
     *
     * short 外显个数
     * for(count){
     *     varint32 外显int值 model
     * }
     * varint32 场景id id
     * varint32 地图id mapId
     * varint32 场景类型 sceneType
     * varint32 玩家坐标x x
     * varint32 玩家坐标y y
     * varint64 当前血量 life
     * varint64 最大血量 maxLife
     * varint64 当前速度 speed
     *
     * varint32 状态个数
     * for(状态个数){
     *      stateID =  byteArray.readVarInt32() // 状态的id, 去config.proto中的状态大全里找
     *      currentStackCount = byteArray.readVarInt32() // 这个状态的层数
     *      disappearTime = byteArray.readVarInt64() // 这个状态消失的时刻 (到了这个时刻自动移除状态icon)
     * }
     *
     * string 仙盟名字,空表示没有
     * string 仙盟id,空表示没有
     * varint32 campType 阵营类型
     * bool 是否是挂机选手
     * string 伴侣的名称
     * varint32 地图是几线
     */
    public static final int S2C_SCENE_LOAD_OK = 3;

    public static ChannelBuffer sceneLoadOk() {
        return newDynamicMessage(MODULE_ID, S2C_SCENE_LOAD_OK);
    }

    /**
     * 停止移动. 发送停止消息给服务器, 本地并立即停止移动. 只有在移动状态下才发送
     */
    public static final int C2S_STOP_MOVING = 4;

    /**
     * 英雄/怪物啥的停止了移动,广播
     *
     * 收到消息后,看下消息中附带的id,如果id不是自己,则让英雄以原速度跑到指定的坐标后才停止,若以原速度跑将超过1秒才能跑到,
     * 则增加移动速度使英雄在1秒钟后跑到目标点,并停止
     *
     * 如果id是自己,判断消息中附带的坐标和客户端本地英雄所站坐标的差,如果误差在2格之内,则不动,继续让客户端停在原地.如果误差>2格,
     * 则同上处理(原速度跑,若超过1秒才能跑到,则以1秒能跑到的速度跑)
     *
     * string 英雄or怪物
     *
     * varint64 移动速度,如果要跑向终点,则以此速度跑
     *
     * varint32 坐标
     *
     * varint32 坐标
     */
    public static final int S2C_STOP_MOVING_OK = 4;

    public static ChannelBuffer stopMovingOk(String id, long speed, int x, int y) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_STOP_MOVING_OK,
                computeUTF(id) + computeVarInt64Size(speed) + computeVarInt32Size(x) + computeVarInt32Size(y));
        writeUTF(buffer, id);
        writeVarInt64(buffer, speed);
        writeVarInt32(buffer, x);
        writeVarInt32(buffer, y);
        return buffer;
    }

    /**
     * 如果玩家从A场景切换到B场景，可以立即发送该条协议，请求各条线的负载。
     * 如果玩家从A场景1线切换到A场景2线，如果此前有请求过本场景的负载信息，则使用原来的数据，否则给服务器发送一条新的请求
     */
    public static final int C2S_GET_LINE_INFO = 5;

    /**
     * 服务器返回当前的线数, 以及每个场景的负载情况
     *
     * 后面的读取方法
     *
     * short 线数
     * for(线数){
     *     byte 这个byte表示负载当前在线人数，客户端根据在线人数显示各个分线的信息
     * }
     * 每个byte对应每条线的负载情况(从第一条线开始依次的)
     */
    public static final int S2C_GET_LINE_INFO_OK = 5;

    public static ChannelBuffer getLineInfoOk() {
        return newDynamicMessage(MODULE_ID, S2C_GET_LINE_INFO_OK);
    }

    /**
     * 英雄位置同步,在客户端自行移动后同步
     *
     * varint32 x
     * varint32 y
     */
    public static final int C2S_SYNC_POS = 6;

    /**
     * 英雄位置同步成功
     *
     * string 同步的对象的id
     *
     * varint32 坐标
     *
     * varint32 坐标
     */
    public static final int S2C_SYNC_POS_OK = 6;

    public static ChannelBuffer syncPosOk(String id, int x, int y) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_SYNC_POS_OK, computeUTF(id) + computeVarInt32Size(x) + computeVarInt32Size(y));
        writeUTF(buffer, id);
        writeVarInt32(buffer, x);
        writeVarInt32(buffer, y);
        return buffer;
    }

    /**
     * 1 同步的点不可行走
     */
    public static final int S2C_SYNC_POS_ERR = 7;

    public static ChannelBuffer ERR_SYNC_POS_CAN_MOVE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_SYNC_POS_ERR, 1);

    /**
     * 切换pk模式
     *
     * varint32 pk模式 1-和平 2-强制 3-全体
     */
    public static final int C2S_CHANGE_PK_MODE = 7;

    /**
     * 切换pk模式成功
     *
     * varint32 当前pk模式
     */
    public static final int S2C_CHANGE_PK_MODE_OK = 8;

    public static ChannelBuffer changePkModeOk(int pkMode) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_CHANGE_PK_MODE_OK, computeVarInt32Size(pkMode));
        writeVarInt32(buffer, pkMode);
        return buffer;
    }

    /**
     * 复活
     *
     * varint32 复活类型 0-原地复活 1-回城(回复活点)复活
     */
    public static final int C2S_RELIVE = 8;

    /**
     * 复活成功,用来计数，复活后状态走另外消息同步
     *
     * varint32 复活类型
     */
    public static final int S2C_RELIVE_OK = 9;

    public static ChannelBuffer reliveOk(int reliveType) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_RELIVE_OK, computeVarInt32Size(reliveType));
        writeVarInt32(buffer, reliveType);
        return buffer;
    }

    /**
     * 1 场景不可切换pk模式
     * 2 错误的pk模式
     */
    public static final int S2C_CHANGE_PK_MODE_ERR = 10;

    public static ChannelBuffer ERR_CHANGE_PK_MODE_FIXED_PK_SCENE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_CHANGE_PK_MODE_ERR, 1);
    public static ChannelBuffer ERR_CHANGE_PK_MODE_INVALID_PK_MODE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_CHANGE_PK_MODE_ERR, 2);

    /**
     * 1 还活着
     * 2 复活类型错误
     * 3 现在不能复活
     */
    public static final int S2C_RELIVE_ERR = 11;

    public static ChannelBuffer ERR_RELIVE_ALIVE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_RELIVE_ERR, 1);
    public static ChannelBuffer ERR_RELIVE_INVALID_TYPE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_RELIVE_ERR, 2);
    public static ChannelBuffer ERR_RELIVE_CANT_RELIVE = onlySendHeadAndAByteMessage(MODULE_ID, S2C_RELIVE_ERR, 3);

    /**
     * 传送
     *
     * varint32 传送id
     */
    public static final int C2S_TRANSPORT = 9;

    /**
     * 传送成功,场景加载和视野变化走通用消息
     */
    public static final int S2C_TRANSPORT_OK = 12;

    public static final ChannelBuffer transportOk = onlySendHeaderMessage(MODULE_ID, S2C_TRANSPORT_OK);

    /**
     * 1 传送id错误
     * 2 不在传送区域内
     * 3 当前状态中不能传送
     * 4 目标场景等级不足,不能进入
     * 5 死了不能传送
     */
    public static final int S2C_TRANSPORT_ERR = 13;

    public static ChannelBuffer ERR_TRANSPORT_INVALID_ID = onlySendHeadAndAByteMessage(MODULE_ID, S2C_TRANSPORT_ERR, 1);
    public static ChannelBuffer ERR_TRANSPORT_NOT_IN_AREA = onlySendHeadAndAByteMessage(MODULE_ID, S2C_TRANSPORT_ERR, 2);
    public static ChannelBuffer ERR_TRANSPORT_CANT_TRANSPORT = onlySendHeadAndAByteMessage(MODULE_ID, S2C_TRANSPORT_ERR, 3);
    public static ChannelBuffer ERR_TRANSPORT_LEVEL_LIMIT = onlySendHeadAndAByteMessage(MODULE_ID, S2C_TRANSPORT_ERR, 4);
    public static ChannelBuffer ERR_TRANSPORT_IS_DEAD = onlySendHeadAndAByteMessage(MODULE_ID, S2C_TRANSPORT_ERR, 5);

    /**
     * 客户端请求拾取道具
     *
     * varint32 场景道具id
     */
    public static final int C2S_PICK_UP_GOODS = 10;

    /**
     * 物品被拾取，收到S2C_PICK_UP_GOODS消息
     *
     * varint32 场景道具id
     *
     * 客户端收到这条消息后，删掉场景中的拾取物品
     */
    public static final int S2C_PICK_UP_GOODS_OK = 14;

    public static ChannelBuffer pickUpGoodsOk(int id) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_PICK_UP_GOODS_OK, computeVarInt32Size(id));
        writeVarInt32(buffer, id);
        return buffer;
    }

    /**
     * 拾取道具失败
     *
     * 1 拾取的物品不存在
     * 2 物品不属于你
     * 3 与物品距离过远,服务器检测2格以内，客户端需要走到物品所在的位置上面
     * 4 背包已满
     * 5 跳跃中
     * 6 挂了
     * 7 防沉迷中
     * 8 拾取物品cd中
     */
    public static final int S2C_PICK_UP_GOODS_ERR = 15;

    public static ChannelBuffer ERR_PICK_UP_GOODS_NOT_EXIST = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 1);
    public static ChannelBuffer ERR_PICK_UP_GOODS_NOT_YOURS = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 2);
    public static ChannelBuffer ERR_PICK_UP_GOODS_TOO_FAR = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 3);
    public static ChannelBuffer ERR_PICK_UP_GOODS_DEPOT_IS_FULL = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 4);
    public static ChannelBuffer ERR_PICK_UP_GOODS_IS_JUMP = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 5);
    public static ChannelBuffer ERR_PICK_UP_GOODS_DEAD = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 6);
    public static ChannelBuffer ERR_PICK_UP_GOODS_FCM = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 7);
    public static ChannelBuffer ERR_PICK_UP_GOODS_IN_CD = onlySendHeadAndAByteMessage(MODULE_ID, S2C_PICK_UP_GOODS_ERR, 8);

    /**
     * 无参数
     * 客户端取消进度条
     */
    public static final int C2S_CANCEL_PROGRESS_BAR = 11;

    /**
     * 如果这个人身上有进度条特效，则移除，没有就不管
     *
     * string 角色ID
     */
    public static final int S2C_CANCEL_PROGRESS_BAR_OK = 16;

    public static ChannelBuffer cancelProgressBarOk(String roleId) {
        ChannelBuffer buffer = newFixedSizeMessage(MODULE_ID, S2C_CANCEL_PROGRESS_BAR_OK, computeUTF(roleId));
        writeUTF(buffer, roleId);
        return buffer;
    }

    /**
     * 客户端挂机状态变化
     *
     * bool 是否挂机
     */
    public static final int C2S_CLIENT_AUTO_FIGHT_STATUS = 12;

    /**
     * 离开副本
     */
    public static final int C2S_LEAVE_DUNGEON = 13;

    /**
     * 离开副本成功
     */
    public static final int S2C_LEAVE_DUNGEON_OK = 17;

    public static final ChannelBuffer leaveDungeonOk = onlySendHeaderMessage(MODULE_ID, S2C_LEAVE_DUNGEON_OK);

    /**
     * 请求某个场景中的同服英雄数据，发送后锁定面板，直到收到返回解锁
     *
     * varint32 type，type是下面的单个类型，必须10S才能请求一次
     *
     *      0. 附近的英雄
     *      1. 附近的队伍
     *      2. 附近沒有隊伍的人
     */
    public static final int C2S_GET_SURROUNDING_INFO = 14;

    /**
     * 请求某个场景中的同服英雄数据成功
     *
     * varint32 type
     *
     * if(type是附近的人or附近沒有隊伍的人){
     *     short count
     *     for(count) {
     *         string 玩家id
     *         string 玩家名字
     *         varint32 职业，即RaceId
     *         varint32 等级
     *         varint32 转职等级
     *     }
     * }
     *
     * if(type是附近队伍){
     *     short count
     *     for(count) {
     *         varint32 队伍当前人数
     *         varint32 队伍最大人数
     *         string 队长id
     *         string 队长名字
     *         varint32 职业，即RaceId
     *         varint32 等级
     *         varint32 转职等级
     *     }
     * }
     */
    public static final int S2C_GET_SURROUNDING_INFO_OK = 18;

    public static ChannelBuffer getSurroundingInfoOk() {
        return newDynamicMessage(MODULE_ID, S2C_GET_SURROUNDING_INFO_OK);
    }

    /**
     * 采集争夺性采集物
     * string 采集物在场景中的id
     */
    public static final int C2S_COLLECT_COMPETE_OBJECT = 15;

    /**
     * 回到主城出生点
     */
    public static final int C2S_GO_BACK_HOME_SCENE = 16;

    /**
     * 回到主城出生点
     */
    public static final int S2C_GO_BACK_HOME_SCENE_OK = 19;

    public static final ChannelBuffer goBackHomeSceneOk = onlySendHeaderMessage(MODULE_ID, S2C_GO_BACK_HOME_SCENE_OK);

    /**
     * 传送
     *
     * varint32 副本传送点id
     */
    public static final int C2S_DUNGEON_TRANSPORT = 17;

    /**
     * 传送成功,场景加载和视野变化走通用消息
     */
    public static final int S2C_DUNGEON_TRANSPORT_OK = 20;

    public static final ChannelBuffer dungeonTransportOk = onlySendHeaderMessage(MODULE_ID, S2C_DUNGEON_TRANSPORT_OK);

    /**
     * 切线，成功之后返回 S2C_CHANGE_SCENE
     * varint32 几线
     */
    public static final int C2S_CHANGE_LINE = 18;

}